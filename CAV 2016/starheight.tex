\newcommand{\cB}{\mathcal B}
% \newcommand{\trans}[1]{\stackrel{#1}{\longrightarrow}}

\section{The Star-height algorithm}

The latest algorithm in the literature for computing star-height is designed for tree automata \cite{CL08sh}, but we will use it here in the special case of words. The main improvement over the previous algorithm from \cite{Kirsten05} is the identification of the structure of Subset Automata, which allows minimization.

We describe here briefly the ideas of the algorithm.

\subsection{Subset automata}

\begin{definition}\cite{CL08sh}
A subset automaton $\A$ is a deterministic automaton with additional $\epsilon$-transitions, such that $\epsilon$-transitions encode a lattice structure on the state space of $\A$. More precisely, $\epsilon$-transitions define a partial order on states, and for all states $p,q$, there are states $x,y$ such that $x\trans{\epsilon}p, x\trans{\epsilon}q, p\trans{\epsilon}y$ and $q\trans{\epsilon}y$.
\end{definition}

Due to the algebraic nature of their definition, subset automata can be minimized in a similar way to deterministic automata.

\begin{theorem}\cite{CL08sh}
Any language can be recognized by a subset automaton, obtained by a powerset construction from a non-deterministic automaton for the complement language.
\end{theorem}

\subsection{Reduction to limitedness}
%
%Let $\A=\perm{A,Q,q_0,F_\A,\Delta_\A}$ be a subset automaton for a language $L$, and $k\in \mathbb N$. We recall that there are $\epsilon$-transitions, so $\Delta_\A\subseteq Q\times (A\cup\{\epsilon\})\times Q$.
%
%We build a $B$-automaton $\cB$ with $k+1$ counters $\gamma_0,\gamma_1,\dots,\gamma_k$, and states $Q_\cB=\bigcup_{i=1}^{k+1} Q^i$ that we view as a subset of $Q^*$.
%
%Let $j\in[0,k]$, we will note $R_j$ the counter action performing $\re$ on counters $\gamma_p$ with $p\geq j$ and $\e$ on counters $\gamma_p$ with $p<j$. Simlarly, we will note $I_j$ the counter action performing $\re$ on counters $\gamma_p$ with $p> j$, $\ic$ on counter $\gamma_j$, and $\e$ on counters $\gamma_p$ with $p<j$. We finally note $\e$ the action performing $\e$ on all counters.
%These particular counter actions are called \emph{hierarchical}, they correspond to the nested distance automata from \cite{Kirsten05}. Their advantage over general actions on multiple counters is that there is a total order or preference, namely $R_0 \leq R_1 \leq \dots \leq R_k \leq \e \leq I_0 \leq I_1 \leq \dots \leq I_k$. This greatly simplifies the shape of elements of the stabilization monoid, since for each pair of states $(q_i,q_j)$ it suffices to store the best possible action to go from $q_i$ to $q_j$ instead of the set of all available actions.
%
%The automaton $\cB$ is defined as follows:
%
%\begin{itemize}
%\item The initial state is $q_0$ (word of length $1$).
%\item A state $wp$ is final if and only if $p\in F_\A$.
%\item If $(p,a,q)\in\Delta_\A$ and $w\in Q^{\leq k}$, there is a transition $wp\trans{a:I_{|w|}}wq$ in $\cB$. If $a=\epsilon$, the action may equivalently be replaced by $\e$, as we do in the implementation.
%\item If $w\in Q^{\leq k-1}$ and $p\in Q_\A$, there is a transition $wp\trans{\epsilon:R_{|wp|}}wpp$ in $\cB$.
%\item If $w\in Q^{\leq k-1}$ and $q,p\in Q_\A$, there is a transition $wpq\trans{\epsilon:R_{|wp|}}wq$ in $\cB$.
%\end{itemize}

In \cite{CL08sh}, it is shown that given a non-deterministic automaton $\A$ for the complement of a language $L$ (or alternatively a deterministic automaton for $L$), and an integer $k$, we can build a $B$-automaton $\cB$ which is limited if and only if $L$ is expressible with a regular expression of star-height $k$.

Therefore, for any fixed $k$, we can decide whether a regular language has star-height $k$.

The construction of $\cB$ goes through an intermediary subset automaton $\A'$ obtained as a powerset of $\A$. This automaton $\A'$ can be minimized before being used to build $\cB$, thanks to its structure of subset automaton.
We implemented this minimization as an additionnal optimization step.
%

%\begin{framed}
%We are given as input an integer $k$ and the dual of the non-deterministic automaton for $A^*\setminus L$. In particular a deterministic automaton for $L$ works.
%\begin{enumerate}
%	\item Build a subset automaton $\A$ via a powerset construction (exponential space),
%	\item compute the minimal subset automaton $\A_m$ of $L$ from $\A$,
%	\item build the automaton $\cB$ as above,
%	\item check $\cB$ for limitedness using the stabilization monoid algorithm.
%\end{enumerate}
%\end{framed}



\subsection{Complexity}

Let $n$ be the size of the input automaton.
The automaton $\cB$ is of size $O(2^{nk})$, and moreover the stabilization monoid is exponential in the size of $\cB$.

Therefore, our algorithm as it is written runs in time and space $O(2^{2^{nk}})$. However, the limitedness step could be performed in PSPACE (in the size of $\cB$) using on-the-fly computation on the monoid, 
so the theoretical complexity of the problem is EXPSPACE for an input of this shape. 
Note that Kirsten's algorithm uses doubly exponential space because it takes a non-deterministic automaton for $L$ as input.

\subsection{Loop complexity heuristic}

\newcommand{\lc}{\mathrm{LC}}

Given an automaton $\A$, its \emph{loop complexity} $\lc(\A)$ is the optimal star-height of an expression obtained from it via standard algorithms \cite{Eggan63}. Moreover, the star-height of a language $L$ is equal to $\min\{\lc(\A)| L(\A)=L\}$.

There are many natural cases where the star-height is equal to the loop-complexity of the input automaton \cite{Cohen70}, for instance if all transition labels are distincts. These automata are relevant for instance for modelling processes where communication between two components (states) are uniquely identified. 

Since computing the loop-complexity is exponentially faster than the star-height algorithm, we start by computing ``for free'' an expression witnessing the loop-complexity.

Additionnally, we argue we can use this expression as a speed-up for the main algorithm, in two different ways.
First, the loop-complexity provides an upper bound for star-height, and we can therefore stop the search if all heights strictly lower have been tested.
The second way is heuristic: during the tests of Acme++, it seemed that such expressions witnessing loop complexity could often be used as unboundedness witnesses in the computed stabilization monoid, in cases where the loop complexity does not match the star-height.

Moreover, having computed this expression allows us to provide a witness of optimal star-height when it matches the loop-complexity. In general, the star-height algorithm does not provide any witness.

This naturally led us to implement a heuristic using these locally optimal expressions.
When testing star-height $h$ for an input automaton $\A$ (starting with $h=0$), we execute the following steps:

\begin{itemize}
\item Compute a regular expression $e$ matching $\lc(\A)$.
\item If $\lc(\A)=h$, then return $h$ together with $e$ and stop.
\item Otherwise, turn $e$ into a $\sharp$-expression $e'$ by removing disjunctions.
\item Test $e'$ as unboundedness witness in the stabilization monoid.
	\begin{itemize} 
	\item If $e'$ is such a witness, increase $h$, and go back to Step 1,
	\item Otherwise, test unboundedness, and increase $h$ if a witness is found. 
	\end{itemize}
\end{itemize}

%The purpose of this heuristic is two-fold. First, speeding up the star-height algorithm by priviledging certain witnesses and stopping when we reach $\lc(\A)$ (this avoids the computation of a stabilization monoid). Second, providing a witness expression of optimal star-height when it matches $\lc(\A)$ (as no witness is produce by the general algorithm).


