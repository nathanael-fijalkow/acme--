
\section{Computing the Stabilization Monoid of an Automaton}

We report here on our implementation of the following algorithmic task:
\begin{framed}
We are given as input:
\begin{itemize}
	\item A finite set of matrices $S$,
	\item A binary associative operation on matrices, the product, denoted $\cdot$,
	\item A unary operation on matrices, the stabilization, denoted $\sharp$.
\end{itemize}
The aim is to compute the closure of $S$ under product and stabilization,
called the stabilization monoid generated by $S$.
\end{framed}

Note that if we ignore the stabilization operation, this reduces to computing the monoid generated by a finite set of matrices.
It is well-known that this monoid can be exponential in the size of the matrices,
so the crucial aspect here is space optimization.
We describe two optimizations that allow to significantly reduce space consumption.

Recall that in our application, the initial set of matrices is given by matrices $M_a$ for $a \in A$, 
where $A$ is the finite alphabet of the automaton.
Hence we naturally associate to every element of the stabilization monoid a $\sharp$-expression:
$(M_a \cdot M_b^\sharp \cdot M_a)^\sharp$ is associated to $(a b^\sharp a)^\sharp$.
Many $\sharp$-expressions actually correspond to the same matrix: for instance, it may be that
$(M_a \cdot M_a \cdot M_b)^\sharp = M_a^\sharp$.

\vskip1em
%The algorithm saturates $S$, alternating between closure by product and closure by stabilization.
The first optimization consists in storing a set $R$ of rewriting rules between $\sharp$-expressions,
in order to reduce as much as possible the number of products and stabilizations.

A typical step in the algorithm is to construct a new $\sharp$-expression using newly constructed elements.
Before computing the corresponding matrix,
we check beforehand that this $\sharp$-expression cannot be reduced used the rewriting
rules known so far:
\begin{itemize}
	\item if it can be reduced, we avoid the costly computation of a product or a stabilization,
	\item it it cannot be reduced, then we compute the corresponding matrix, check whether it appeared
	already. If it did appear, then add a rewriting rule, otherwise add the matrix.
\end{itemize}
This means that the algorithm processes a lot of new $\sharp$-expressions,
and should be able to quickly detect if a $\sharp$-expression can be rewritten using the set $R$.
This task is performed very efficiently thanks to an optimized representation of $R$
using pointers and a Hashing table.

\vskip1em
The second optimization is about how matrices themselves are stored in memory.
%The three operations performed on matrices are product, stabilization and equality check.
Empirically, although the stabilization monoid may contain a lot of different matrices,
these matrices are very similar to each other.
In particular, if we consider the set of lines of these matrices, it is rather small compared to the number of matrices.
Hence the idea of storing lines in a table, and matrices as a set of pointers to the corresponding lines.
This simple idea turned out to be a game changer.

The algorithm is presented in Algorithm~\ref{algo}.
\RestyleAlgo{boxed}
\begin{algorithm}[ht]
\KwData{$S = \set{(M_a,a) \mid a \in A}$}
\KwResult{The stabilization monoid generated by $S$}
Initialization: 
$\New = S$ and $R = \emptyset$ set of rewriting rules\;

\While{$\New \neq \emptyset$}{

	// Closure by product\;
	$\New_T = \New$\;
	$\New = \emptyset$\;
	\For{$(M,m) \in \New_T$}{
		\For{$(N,n) \in S$}{
			\If{$m \cdot n$ is not reducible using $R$}{
				Compute $M \cdot N$\;
				\If{$(M \cdot N,w)$ is in $S$ for some $w$}{
					Add $m \cdot n \rightarrow w$ to $R$\;
				}\Else{
					Add $(M \cdot N,m \cdot n)$ to $\New_T$ and to $\New$\;
				}
			}
		}
	}
	\vskip1em
	// Closure by stabilization\;
	$\New_T = \New$\;
	\For{$(M,m) \in \New_T$}{	
		Compute $M^\sharp$\;
		\If{$(M^\sharp,w)$ is in $S$ for some $w$}{
			Add $m^\sharp \rightarrow w$ to $R$\;
		}\Else{
			Add $(M^\sharp,m^\sharp)$ to $\New$\;
		}
	}

	Add $\New$ to $S$\;	
}
\Return{S}\;
\caption{\label{algo}Computing the stabilization monoid}
\end{algorithm}

