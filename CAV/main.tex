\documentclass[11pt]{llncs}

\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{times}
\usepackage{amssymb,amsmath,amscd,latexsym,graphicx}
\usepackage{tikz}
\usetikzlibrary{automata,positioning,calc,shapes.geometric}
\usepackage{framed}
\usepackage[]{algorithm2e}
%\usepackage[usenames]{color}

\newcommand{\set}[1]{\{ #1 \}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\M}{\mathcal{M}}
\newcommand{\perm}[1]{\langle #1 \rangle}
\newcommand{\ic}{\mathbf{ic}}
\newcommand{\e}{\mathbf{e}}
\newcommand{\re}{\mathbf{r}}
\newcommand{\val}[1]{\mathrm{val}(#1)}
\newcommand{\sem}[1]{[\![#1]\!]}
\newcommand{\New}{\mathbf{New}}


\newcommand{\trans}[1]{\stackrel{\longrightarrow}{#1}}
\newcommand{\PSPACE}{\mathrm{PSPACE}}

\def\mynote#1{{\sf $\dagger$ #1 $\dagger$}}

\title{ACME++: Optimizing Stabilization Monoids Computations for Probabilistic Automata and the Star-Height Problem}

\author{Nathana\"el Fijalkow\inst{1,2} \and Hugo Gimbert\inst{3} \and Edon Kelmendi\inst{3} \and Denis Kuperberg\inst{4}}
\institute{LIAFA, Paris 7, France \and University of Warsaw, Poland \and LaBRI, Bordeaux, France \and Onera, Toulouse, France}

\begin{document}

\maketitle
\begin{abstract}
We present ACME++, 
a tool implementing part of the theory of regular cost functions
over finite words. 
This theory is a quantitative extension of the classical theory of regular languages,
which allows to express boundedness properties. 
%Our tool manipulates a special form of automata with counters called $B$-automata,
%and the two main features are to check whether a $B$-automaton is bounded 
%and whether two $B$-automata are equivalent.
%As an algorithmic back-end we rely on stabilization monoids.
%
We provide two applications: first to the classical theory of regular languages,
by solving the star-height problem,
and second to probabilistic automata,
by implementing the Markov Monoid Algorithm. 
This tool is a follow-up to a prveious version, with optimized algorithms, we present a comparative study of their performances.
\end{abstract}

The dedicated webpage where the tool ACME++ can be downloaded is
\begin{center}
\url{http://www.liafa.univ-paris-diderot.fr/\textasciitilde nath/acme++.htm}\ .
\end{center}

\section{Introduction}

Acme++ is a tool for deciding properties of some algebraic structures called stabilization monoids,
with two motivations in mind:
\begin{itemize}
\item provide an effective tool to solve the starheight problem
\item provide a tool to solve the value 1 problem for probabilistic automata.
\end{itemize}

\textbf{The starheight problem}

An excellent introduction about the starheight problem is given in \cite{Kirsten05},
which mentions some of the important industrial applications as
speech recognition \cite{Mohri97}, database theory \cite{GT01}, and image compression \cite{CK93,KMT04}.
This problem was considered as one of the most difficult problems in the theory of recognizable languages
and it took 25 years before being solved by Hashiguchi \cite{Hashiguchi88}.
Implementing Hashiguchi algorithm is hopeless: the algorithm proceeds by enumeration of certain expressions
and has a terrible complexity \cite{LS02}.
It took another 22 years before an algorithm with a better algorithmic complexity was given by Kirsten in \cite{Kirsten05}.
This approach using weighted automata was generalized and inspired the rich theory of regular cost functions \cite{Colcombet09}, which allows to solve other problems reducible to boundedness of automata with counters \cite{CL08sh,CL08b,CKLB13}.

Acme++ aims at solving the starheight  problem for practical applications,
albeit the doubly exponential space complexity of Kirsten algorithm is a challenge to tackle.

We use an optimization from \cite{CL08sh}: the structure of Subset Automata, whose algebraic properties allow minimization.
\smallskip

\textbf{The value 1 problem}

Probabilistic automata are a versatile tool widely used in speech recognition as well as a modelling tool 
for the control of systems with partial observation or no observation.
Probabilistic automata are a natural extension on automata on finite words,
with probabilistic transitions, see \cite{Rabin63} for an introduction.
The value 1 problem is natural when probabilistic automata are used as models
of systems controlled by a blind controller, who is in charge of choosing the
sequence of input letters in order to maximize the acceptance
probability, see \cite{FGO12} for an introduction.
\smallskip

\textbf{Stabilization monoids}

Stabilization monoids are the key mathematical object needed to solve the two questions we are interested in.
The starheight problem is related to the limitedness problem of distance atomata.
A seminal paper by Simon "On semigroups of matrices over the tropical seimrings"
gives a clean easy to read proof 
Then Kirsten showed how monoids could be used to solve the starheight problem using algebraic structures,
giving an alternate proof to th every comple proof of Hashigushi, based on nested distance desert automata.
Desert automata are automata with ranked counters that can be either incremented and reset,
with the extra condition that if a counter is reset all counters of lower rank are reset as well.
Colcombet extended further the work of Kirsten introducing stabilization monoids and generalizing regular language theory into cost function theory, including algebraic and logical characterizations \cite{Colcombet09,CKL10,Kup14}.
The techniques of Simon were adapted to solve the value 1 problem for probabilistic automata \cite{FGO12}.


Acme++ is a set of software tools to handle stabilization monoids, they can generate a stabilization monoid from its generators and test properties of these monoids, in particular the limitedness and the existance of value 1 witnesses.

Our results:
provide a description of experimental results.

\section{Stabilization Monoids for $B$- and Probabilistic Automata}

The notion of stabilization monoids appears in two distinct contexts.
It has first been developed in the theory of regular cost functions,
introduced by Colcombet~\cite{Colcombet09,Colcombet13}.
The underlying ideas have then been transferred to the setting of probabilistic automata~\cite{FGO12}.

\subsection{Stabilization Monoids in the Theory of Regular Cost Functions}

At the heart of the theory of regular cost functions lies the equivalence between different formalisms:
a logical formalism, cost MSO, two automata model, $B$- and $S$-automata, and an algebraic counterpart, stabilization monoids.

Here we briefly describe the model of $B$-automata, and their transformations to stabilization monoid.
This automaton model generalizes the non-deterministic automata by adding a finite set of counters.
Instead of accepting or rejecting a word as a non-deterministic automaton does, 
a $B$-automaton associates an integer value to each input word.
Formally, a $B$-automaton is a tuple $\A = \perm{A,Q,\Gamma,I,F,\Delta}$, where $A$ is a finite alphabet, $Q$ is a finite set of states, 
$\Gamma$ is a finite set of counters, $I \subseteq Q$ is the set of initial states, $F \subseteq Q$ is the set of final states, 
and $\Delta \subseteq Q \times A \times \set{\ic,\e,\re}^\Gamma \times Q$ is the set of transitions.

A transition $(p,a,\tau,q)$ allows the automaton to go from state $p$ to state $q$ while reading letter $a$ and performing action $\tau(\gamma)$ on counter $\gamma$. 
Action $\ic$ increments the current counter value by $1$, $\e$ leaves the counter unchanged, and $\re$ resets the counter to $0$.

%A run of the automaton $\A$ on a word $w = a_1 a_2 \dots a_n$ is a sequence $\rho = q_0,\tau_1,q_1,\tau_2,\dots, \tau_n, q_n$ such that $q_0 \in I, q_n \in F$, 
%and for all $i \in [1,n]$, $(q_{i-1},a_i,\tau_i,q_i) \in \Delta$.
The value of a run is the maximal value assumed by any of the counters during the run.
The semantics of a $B$-automaton $\A$ is defined on a word $w$ by 
$\sem{\A}(w) = \inf\set{\val{\rho} \mid \rho\text{ is a run of } \A \text{ on } w}$.
In other words, the automaton uses the non determinism to minimize the value among all runs.
In particular, if $\A$ has no run on $w$, then $\sem{\A}(w) = \infty$.

%If $\A$ is a $B$-automaton, its semantics $\sem{\A}$ is usually viewed as a cost function, \textit{i.e.} exact values are ignored, 
%and just boundedness properties are considered. 
%Consequently, we say that two $B$-automata $\A_1$ and $\A_2$ are equivalent if $\sem{\A_1}$ and $\sem{\A_2}$ are bounded on the same sets of words.

The main decision problem in the theory of regular cost functions is the limitedness problem.
We say that a $B$-automaton $\A$ is \emph{limited} if there exists $N$ such that for all words $w$, if $\sem{\A}(w) < \infty$, then $\sem{\A}(w) < N$.

\vskip1em
One way to solve the limitedness problem is by computing the stabilization monoid.
It is a monoid of matrices over the semiring of counter actions $\set{\ic,\e,\re,\omega}^\Gamma$.
There are two operations on matrices: a binary composition called product, giving the monoid structure,
and a unary operation called stabilization.
The stabilization monoid of a $B$-automaton is the set of matrices containing the matrices corresponding to each letter,
and closed under the two operations, product and stabilization.
As shown in~\cite{Colcombet09,Colcombet13}, the stabilization monoid of a $B$-automaton $\A$ contains an unlimited witness
if and only if it is not limited,
implying a conceptually simple solution to the limitedness problem: compute the stabilization monoid
and check for the existence of unlimited witnesses.

%Following the celebrated success for the star-height problem, whose decidability has been established by
%reducing it to the limitedness problem of $B$-automata~\cite{Hashiguchi88,Kirsten05}, 
%several problems have been reduced to this problem.
%For instance, we implemented the solution of the finite power property:
%given a regular language $L \subseteq A^*$, does there exist $n \in \N$
%such that $L^* = L^ 0 + L^1 + \cdots + L^n$?
%We reduce this problem to a limitedness problem for $B$-automata, following \cite{Kirsten02}.

\subsection{Stabilization Monoids for Probabilistic Automata}

The notion of stabilization monoids also appeared for probabilistic automata, for the Markov Monoid Algorithm.
This algorithm was introduced in~\cite{FGO12} to partially solves the value $1$ problem: given a probabilistic automaton $\A$,
does there exist $(u_n)_{n \in \N}$ a sequence of words such that $\lim_n \mathbb{P}_\A(u_n) = 1$?

Although the value $1$ problem is undecidable, it has been shown that
the Markov Monoid Algorithm correctly determines whether a probabilistic automaton has value $1$
under the \textit{leaktight} restriction.
It has been recently shown that all classes of probabilistic automata for which the value $1$ problem has been shown decidable 
are included in the class of leaktight automata~\cite{FGKO14},
hence the Markov Monoid Algorithm is the \textit{most correct} algorithm known to (partially) solve the value $1$ problem.

As for the case of $B$-automata, the stabilization monoid of a probabilistic automaton
is the set of matrices containing the matrices corresponding to each letter,
and closed under the two operations, product and stabilization.

Note that the main point is that both the products and the stabilizations depend on which type of automata is considered,
$B$-automata or probabilistic automata.

\section{Computing the Stabilization Monoid of an Automaton}

We report here on our implementation of the following algorithmic task:
\begin{framed}
We are given as input:
\begin{itemize}
	\item A finite set of matrices $S$,
	\item A binary associative operation on matrices, the product, denoted $\cdot$,
	\item A unary operation on matrices, the stabilization, denoted $\sharp$.
\end{itemize}
The aim is to compute the closure of $S$ under product and stabilization,
called the stabilization monoid generated by $S$.
\end{framed}

Note that if we ignore the stabilization operation, this reduces to computing the monoid generated by a finite set of matrices.
It is well-known that this monoid can be exponential in the size of the matrices,
so the crucial aspect here is space optimization.
We describe two optimizations that allowed to significantly reduce space consumption.

Recall that in our application, the initial set of matrices is given by matrices $M_a$ for $a \in A$, 
where $A$ is the finite alphabet of the automaton.
Hence we naturally associate to every element of the stabilization monoid a $\sharp$-expression:
$(M_a \cdot M_b^\sharp \cdot M_a)^\sharp$ is associated to $(a b^\sharp a)^\sharp$.
Many $\sharp$-expressions actually correspond to the same matrix: for instance, it may be that
$(M_a \cdot M_a \cdot M_b)^\sharp = M_a^\sharp$.

\vskip1em
%The algorithm saturates $S$, alternating between closure by product and closure by stabilization.
The first optimization consists in storing a set $R$ of rewriting rules between $\sharp$-expressions,
in order to reduce as much as possible the number of products and stabilization.

A typical step in the algorithm is to construct a new $\sharp$-expression using newly constructed elements.
Before computing the corresponding matrix,
we check beforehand that this $\sharp$-expression cannot be reduced used the rewriting
rules known so far:
\begin{itemize}
	\item if it can be reduced, we avoid the costly computation of a product or a stabilization,
	\item it it cannot be reduced, then we compute the corresponding matrix, check whether it appeared
	already. If it did appear, then add a rewriting rule, otherwise add the matrix.
\end{itemize}
This means that the algorithm processes a lot of new $\sharp$-expressions,
and should be able to quickly detect if a $\sharp$-expression can be rewritten using the set $R$.
This task is performed very efficiently thanks to an optimized representation of $R$
using pointers and a Hashing table.

\vskip1em
The second optimization is about how matrices themselves are stored in memory.
%The three operations performed on matrices are product, stabilization and equality check.
Empirically, although the stabilization monoid may contain a lot of different matrices,
these matrices are very similar to each other.
In particular, if we consider the set of lines of these matrices, it is rather small compared to the number of matrices.
Hence the idea of storing lines in a table, and matrices as a set of pointers to the corresponding lines.
This simple idea turned out to be a game changer.

The algorithm is presented in Algorithm~\ref{algo}.
\begin{framed}
\begin{algorithm}[H]
\KwData{$S = \set{(M_a,a) \mid a \in A}$}
\KwResult{The stabilization monoid generated by $S$}
Initialization: 
$\New = S$ and $R = \emptyset$ set of rewriting rules\;

\While{$\New \neq \emptyset$}{

	// Closure by product\;
	$\New_T = \New$\;
	$\New = \emptyset$\;
	\For{$(M,m) \in \New_T$}{
		\For{$(N,n) \in S$}{
			\If{$m \cdot n$ is not reducible using $R$}{
				Compute $M \cdot N$\;
				\If{$(M \cdot N,w)$ is in $S$ for some $w$}{
					Add $m \cdot n \rightarrow w$ to $R$\;
				}\Else{
					Add $(M \cdot N,m \cdot n)$ to $\New_T$ and to $\New$\;
				}
			}
		}
	}
	\vskip1em
	// Closure by stabilization\;
	$\New_T = \New$\;
	\For{$(M,m) \in \New_T$}{	
		Compute $M^\sharp$\;
		\If{$(M^\sharp,w)$ is in $S$ for some $w$}{
			Add $m^\sharp \rightarrow w$ to $R$\;
		}\Else{
			Add $(M^\sharp,m^\sharp)$ to $\New$\;
		}
	}

	Add $\New$ to $S$\;	
}
\Return{S}\;
\caption{\label{algo}Computing the stabilization monoid}
\end{algorithm}
\end{framed}

\input{starheight}

\bibliographystyle{alpha}
\bibliography{bib}
\end{document}
